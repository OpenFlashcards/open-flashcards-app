/* tslint:disable */
/* eslint-disable */
/**
 * Open Flashcards API
 * Open Flashcards API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CardResponseDto,
  CreateCardDto,
  ForbiddenErrorResponseDto,
  NotFoundErrorResponseDto,
  UnauthorizedErrorResponseDto,
  UpdateCardDto,
  ValidationErrorResponseDto,
} from '../models/index';
import {
    CardResponseDtoFromJSON,
    CardResponseDtoToJSON,
    CreateCardDtoFromJSON,
    CreateCardDtoToJSON,
    ForbiddenErrorResponseDtoFromJSON,
    ForbiddenErrorResponseDtoToJSON,
    NotFoundErrorResponseDtoFromJSON,
    NotFoundErrorResponseDtoToJSON,
    UnauthorizedErrorResponseDtoFromJSON,
    UnauthorizedErrorResponseDtoToJSON,
    UpdateCardDtoFromJSON,
    UpdateCardDtoToJSON,
    ValidationErrorResponseDtoFromJSON,
    ValidationErrorResponseDtoToJSON,
} from '../models/index';

export interface CardControllerCreateCardRequest {
    deckId: number;
    createCardDto: CreateCardDto;
}

export interface CardControllerDeleteCardRequest {
    cardId: number;
}

export interface CardControllerGetCardByIdRequest {
    cardId: number;
}

export interface CardControllerGetCardsByDeckRequest {
    deckId: number;
}

export interface CardControllerUpdateCardRequest {
    cardId: number;
    updateCardDto: UpdateCardDto;
}

/**
 * CardsApi - interface
 * 
 * @export
 * @interface CardsApiInterface
 */
export interface CardsApiInterface {
    /**
     * Creates a new flashcard in the specified deck. The authenticated user must have access to the deck to create cards.
     * @summary Create a new card in a deck
     * @param {number} deckId The ID of the deck to add the card to
     * @param {CreateCardDto} createCardDto Card data to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApiInterface
     */
    cardControllerCreateCardRaw(requestParameters: CardControllerCreateCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CardResponseDto>>;

    /**
     * Creates a new flashcard in the specified deck. The authenticated user must have access to the deck to create cards.
     * Create a new card in a deck
     */
    cardControllerCreateCard(requestParameters: CardControllerCreateCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CardResponseDto>;

    /**
     * Deletes a specific flashcard. Only the creator of the card or deck admins can delete cards.
     * @summary Delete a specific card
     * @param {number} cardId The ID of the card to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApiInterface
     */
    cardControllerDeleteCardRaw(requestParameters: CardControllerDeleteCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Deletes a specific flashcard. Only the creator of the card or deck admins can delete cards.
     * Delete a specific card
     */
    cardControllerDeleteCard(requestParameters: CardControllerDeleteCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Retrieves a specific flashcard by its ID. The authenticated user must have access to the deck containing the card.
     * @summary Get a specific card by ID
     * @param {number} cardId The ID of the card to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApiInterface
     */
    cardControllerGetCardByIdRaw(requestParameters: CardControllerGetCardByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CardResponseDto>>;

    /**
     * Retrieves a specific flashcard by its ID. The authenticated user must have access to the deck containing the card.
     * Get a specific card by ID
     */
    cardControllerGetCardById(requestParameters: CardControllerGetCardByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CardResponseDto>;

    /**
     * Retrieves all flashcards from the specified deck. The authenticated user must have access to the deck.
     * @summary Get all cards from a deck
     * @param {number} deckId The ID of the deck to get cards from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApiInterface
     */
    cardControllerGetCardsByDeckRaw(requestParameters: CardControllerGetCardsByDeckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CardResponseDto>>>;

    /**
     * Retrieves all flashcards from the specified deck. The authenticated user must have access to the deck.
     * Get all cards from a deck
     */
    cardControllerGetCardsByDeck(requestParameters: CardControllerGetCardsByDeckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CardResponseDto>>;

    /**
     * Updates a specific flashcard by its ID. Only the creator of the card or deck admins can update cards. Fields that are not provided will remain unchanged. You can also move the card to a different deck by providing a deckId - you must have access to the target deck.
     * @summary Update a specific card
     * @param {number} cardId The ID of the card to update
     * @param {UpdateCardDto} updateCardDto Card data to update (only provide fields you want to change)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApiInterface
     */
    cardControllerUpdateCardRaw(requestParameters: CardControllerUpdateCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CardResponseDto>>;

    /**
     * Updates a specific flashcard by its ID. Only the creator of the card or deck admins can update cards. Fields that are not provided will remain unchanged. You can also move the card to a different deck by providing a deckId - you must have access to the target deck.
     * Update a specific card
     */
    cardControllerUpdateCard(requestParameters: CardControllerUpdateCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CardResponseDto>;

}

/**
 * 
 */
export class CardsApi extends runtime.BaseAPI implements CardsApiInterface {

    /**
     * Creates a new flashcard in the specified deck. The authenticated user must have access to the deck to create cards.
     * Create a new card in a deck
     */
    async cardControllerCreateCardRaw(requestParameters: CardControllerCreateCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CardResponseDto>> {
        if (requestParameters['deckId'] == null) {
            throw new runtime.RequiredError(
                'deckId',
                'Required parameter "deckId" was null or undefined when calling cardControllerCreateCard().'
            );
        }

        if (requestParameters['createCardDto'] == null) {
            throw new runtime.RequiredError(
                'createCardDto',
                'Required parameter "createCardDto" was null or undefined when calling cardControllerCreateCard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/cards/deck/{deckId}`;
        urlPath = urlPath.replace(`{${"deckId"}}`, encodeURIComponent(String(requestParameters['deckId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCardDtoToJSON(requestParameters['createCardDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CardResponseDtoFromJSON(jsonValue));
    }

    /**
     * Creates a new flashcard in the specified deck. The authenticated user must have access to the deck to create cards.
     * Create a new card in a deck
     */
    async cardControllerCreateCard(requestParameters: CardControllerCreateCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CardResponseDto> {
        const response = await this.cardControllerCreateCardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a specific flashcard. Only the creator of the card or deck admins can delete cards.
     * Delete a specific card
     */
    async cardControllerDeleteCardRaw(requestParameters: CardControllerDeleteCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['cardId'] == null) {
            throw new runtime.RequiredError(
                'cardId',
                'Required parameter "cardId" was null or undefined when calling cardControllerDeleteCard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/cards/{cardId}`;
        urlPath = urlPath.replace(`{${"cardId"}}`, encodeURIComponent(String(requestParameters['cardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a specific flashcard. Only the creator of the card or deck admins can delete cards.
     * Delete a specific card
     */
    async cardControllerDeleteCard(requestParameters: CardControllerDeleteCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cardControllerDeleteCardRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves a specific flashcard by its ID. The authenticated user must have access to the deck containing the card.
     * Get a specific card by ID
     */
    async cardControllerGetCardByIdRaw(requestParameters: CardControllerGetCardByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CardResponseDto>> {
        if (requestParameters['cardId'] == null) {
            throw new runtime.RequiredError(
                'cardId',
                'Required parameter "cardId" was null or undefined when calling cardControllerGetCardById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/cards/{cardId}`;
        urlPath = urlPath.replace(`{${"cardId"}}`, encodeURIComponent(String(requestParameters['cardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CardResponseDtoFromJSON(jsonValue));
    }

    /**
     * Retrieves a specific flashcard by its ID. The authenticated user must have access to the deck containing the card.
     * Get a specific card by ID
     */
    async cardControllerGetCardById(requestParameters: CardControllerGetCardByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CardResponseDto> {
        const response = await this.cardControllerGetCardByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all flashcards from the specified deck. The authenticated user must have access to the deck.
     * Get all cards from a deck
     */
    async cardControllerGetCardsByDeckRaw(requestParameters: CardControllerGetCardsByDeckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CardResponseDto>>> {
        if (requestParameters['deckId'] == null) {
            throw new runtime.RequiredError(
                'deckId',
                'Required parameter "deckId" was null or undefined when calling cardControllerGetCardsByDeck().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/cards/deck/{deckId}`;
        urlPath = urlPath.replace(`{${"deckId"}}`, encodeURIComponent(String(requestParameters['deckId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CardResponseDtoFromJSON));
    }

    /**
     * Retrieves all flashcards from the specified deck. The authenticated user must have access to the deck.
     * Get all cards from a deck
     */
    async cardControllerGetCardsByDeck(requestParameters: CardControllerGetCardsByDeckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CardResponseDto>> {
        const response = await this.cardControllerGetCardsByDeckRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a specific flashcard by its ID. Only the creator of the card or deck admins can update cards. Fields that are not provided will remain unchanged. You can also move the card to a different deck by providing a deckId - you must have access to the target deck.
     * Update a specific card
     */
    async cardControllerUpdateCardRaw(requestParameters: CardControllerUpdateCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CardResponseDto>> {
        if (requestParameters['cardId'] == null) {
            throw new runtime.RequiredError(
                'cardId',
                'Required parameter "cardId" was null or undefined when calling cardControllerUpdateCard().'
            );
        }

        if (requestParameters['updateCardDto'] == null) {
            throw new runtime.RequiredError(
                'updateCardDto',
                'Required parameter "updateCardDto" was null or undefined when calling cardControllerUpdateCard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT-auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/cards/{cardId}`;
        urlPath = urlPath.replace(`{${"cardId"}}`, encodeURIComponent(String(requestParameters['cardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCardDtoToJSON(requestParameters['updateCardDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CardResponseDtoFromJSON(jsonValue));
    }

    /**
     * Updates a specific flashcard by its ID. Only the creator of the card or deck admins can update cards. Fields that are not provided will remain unchanged. You can also move the card to a different deck by providing a deckId - you must have access to the target deck.
     * Update a specific card
     */
    async cardControllerUpdateCard(requestParameters: CardControllerUpdateCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CardResponseDto> {
        const response = await this.cardControllerUpdateCardRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
